// Generated by CoffeeScript 1.10.0
(function() {
  var generate_charts;

  String.prototype.firstUpper = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
  };

  google.charts.load('current', {
    packages: ['corechart']
  });

  generate_charts = function(bm) {
    var sets, sets2;
    sets = {
      mic: {
        '4000-TH': bm.mic._4000x1000.threads,
        '4000-FF': bm.mic._4000x1000.fastflow,
        '8000-TH': bm.mic._8000x1000.threads,
        '8000-FF': bm.mic._8000x1000.fastflow
      },
      xeon: {
        '4000-TH': bm.xeon._4000x1000.threads,
        '4000-FF': bm.xeon._4000x1000.fastflow,
        '8000-TH': bm.xeon._8000x1000.threads,
        '8000-FF': bm.xeon._8000x1000.fastflow
      }
    };
    google.charts.setOnLoadCallback(function() {
      var _s, chart, div, every_set, every_size, i, j, k, l, max, min, p, ref, ref1, results1, s, set, ss, subsets, t, table, tables;
      results1 = [];
      for (_s in sets) {
        subsets = sets[_s];
        every_set = function(map) {
          var results2, s, set;
          results2 = [];
          for (s in subsets) {
            set = subsets[s];
            results2.push(map(set));
          }
          return results2;
        };
        every_size = function(map) {
          var ref, results, size, size_set;
          results = [];
          ref = bm[_s];
          for (size in ref) {
            size_set = ref[size];
            results = results.concat(map(size_set));
          }
          return results;
        };
        tables = {
          times: new google.visualization.DataTable(),
          speedup: new google.visualization.DataTable(),
          scalability: new google.visualization.DataTable(),
          efficiency: new google.visualization.DataTable()
        };
        for (k in tables) {
          table = tables[k];
          table.addColumn('number', 'threads');
          for (set in subsets) {
            table.addColumn('number', set);
          }
        }
        min = 9999999;
        max = -1;
        for (i = j = 0, ref = bm[_s]._4000x1000.threads.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          p = bm[_s]._4000x1000.threads[i][0];
          min = Math.min(min, p);
          max = Math.max(max, p);
          tables.times.addRows([
            [p].concat(every_set(function(set) {
              return set[i][1];
            }))
          ]);
          tables.scalability.addRows([
            [p].concat(every_set(function(set) {
              return set[0][1] / set[i][1];
            }))
          ]);
          tables.efficiency.addRows([
            [p].concat(every_set(function(set) {
              return set[0][1] / set[i][1] / p;
            }))
          ]);
          tables.speedup.addRows([
            [p].concat(every_size(function(size) {
              return [size.sequential[0][1] / size.threads[i][1], size.sequential[0][1] / size.fastflow[i][1]];
            }))
          ]);
        }
        tables.timings = {};
        for (s in subsets) {
          set = subsets[s];
          ss = _s + "_" + s;
          table = tables.timings[ss] = new google.visualization.DataTable();
          table.addColumn('number', 'x');
          table.addColumn('number', 'avg');
          for (i = l = 1, ref1 = set[0].length - 2; 1 <= ref1 ? l <= ref1 : l >= ref1; i = 1 <= ref1 ? ++l : --l) {
            table.addColumn({
              id: 'i' + i,
              type: 'number',
              role: 'interval'
            });
          }
          table.addRows(set);
          if (div = document.getElementById(ss + "_timings_chart")) {
            chart = new google.visualization.LineChart(div);
            chart.draw(table, {
              subtitle: 'Timings',
              intervals: {
                style: 'bars'
              },
              hAxis: {
                title: 'threads'
              },
              vAxis: {
                minValue: 0,
                title: 'time (s)'
              }
            });
          }
        }
        results1.push((function() {
          var results2;
          results2 = [];
          for (t in tables) {
            table = tables[t];
            if (div = document.getElementById(_s + "_" + t + "_chart")) {
              chart = new google.visualization.LineChart(div);
              results2.push(chart.draw(table, {
                hAxis: {
                  title: 'threads'
                },
                vAxis: {
                  minValue: 0,
                  title: t
                },
                pointsVisible: true,
                pointSize: 4,
                explorer: {
                  actions: ['dragToZoom', 'rightClickToReset'],
                  keepInBounds: true
                }
              }));
            } else {
              results2.push(void 0);
            }
          }
          return results2;
        })());
      }
      return results1;
    });
    sets2 = {
      mic: {
        novec: bm.mic_no_vec._4000x1000.threads,
        "default": bm.mic._4000x1000.threads
      },
      xeon: {
        novec: bm.xeon_no_vec._4000x1000.threads,
        "default": bm.xeon_sse2._4000x1000.threads,
        avx: bm.xeon._4000x1000.threads
      }
    };
    return google.charts.setOnLoadCallback(function() {
      var arch, cells, chart, data, last, maxp, minp, subset;
      data = new google.visualization.DataTable();
      data.addColumn('string', 'architecture-size-parallelism');
      data.addColumn('number', 'No vect');
      data.addColumn('number', 'Default');
      data.addColumn('number', 'AVX');
      for (arch in sets2) {
        subset = sets2[arch];
        arch = arch.firstUpper();
        cells = 4000 * 4000 * 1000;
        minp = subset.novec[0][0];
        last = subset.novec.length - 1;
        maxp = subset.novec[last][0];
        data.addRows([[arch + " " + minp + "th", cells / subset.novec[0][1], cells / subset["default"][0][1], subset.avx != null ? cells / subset.avx[0][1] : 0], [arch + " " + maxp + "th", cells / subset.novec[last][1], cells / subset["default"][last][1], subset.avx != null ? cells / subset.avx[last][1] : 0]]);
      }
      chart = new google.visualization.ColumnChart(document.getElementById('vectorization_speedup'));
      return chart.draw(data, {
        hAxis: {
          title: 'Architecture, parallelism degree'
        },
        vAxis: {
          title: 'Cells per second (higher is better)',
          format: 'scientific',
          gridlines: {
            count: 10
          }
        }
      });
    });
  };

  ajax({
    url: 'benchmarks.json',
    dataType: 'json',
    success: generate_charts
  });

}).call(this);
